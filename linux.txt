Заметки по работе с системными командами и консольными утилитами Linux

# filesystem
# curl
# json
# brew
# yq
# xml
# grep
# sed
# awk
# printf
# cut
# tr
# man
# tools
# find
# cron
# systemctl
# netcat
# ncat
# socat
# iperf
# rustscan
# nmap
# vnstat
# iftop
# tcpdump
# tshark
# dig
# mtr
# ss
# ip
# net-tools
# networkd
# resolved
# networkmanager
# iw
# networking
# netplan
# yamllint
# iptables
# ufw
# firewalld
# nftables
# ssh
# openssl
# apt
# snap
# dpkg
# wget
# time
# ntp
# realmd
# cifs
# sudoers
# top
# htop
# atop
# iotop
# jobs
# ps
# kill
# lsof
# descriptor
# strace
# vmstat
# sysstat
# stress
# sensors
# hdparm
# mem
# hardware
# sysctl
# limits
# quota
# journalctl
# syslog
# logrotate
# disk
# swap
# lvm
# md
# tgt
# dd
# users
# chmod
# samba
# nfs
# ftp
# rsync
# privoxy
# apache
# nginx
# haproxy
# keepalive
# elk
# ansible
# jenkins

## filesystem

file Console-Performance.sh # узнать тип файла (текстовый, испоолняемый файл, архив или другой)
stat Console-Performance.sh # узнать размер файла, количество блоков, занятых файлом на диске, количество жестких ссылок, права доступа и временные метки 
pwd # текущая директория
ls -lh * # отобразить содержимое каждого подкаталога отдельно
ls -lhaF # отобразить скрытые директории (-a) с точкой и выделит директории (/)
which top # узнать путь до исполняемого файла
stat $(which top) # узнать дату последнего доступа к файлу 
cat -n /etc/passwd # просмотр содержимого файла с отображением номеров строк
mkdir # создать директорию
mktemp -d # создать временный файл/каталог (-d)
touch -t 202106222200.15 test.file # создать файл и указать дату создания
cp test.file test.file2 # копировать файла/каталог
mv test.file2 test.file3 # переименовать/переместить файл/каталог
rm -r test.file # удалить каталог с файлами (-r)

### ln

echo "test" > testfile
ln /test/testfile /test/testlink # создать жестку (hard) ссылку, которая указывает на один и тот же inode, т.е. они делят одно и то же физическое местоположение на диске
rm testfile # при удалении одного из файлов не приводит к удалению содержимого, пока существует хотя бы одна жесткая ссылка
ln -s /test/testfile /test/testlink # создать символическую (-s - soft) ссылку, которая ссылается на файл testfile
echo "test" >> testfile # при добавлении в оригинальный файл, все изменения будут отражены в testlink
rm testfile # при удалении исходного файла у ссылки будет ошибка (No such file or directory)

### zip

rar a test.rar filename filename2 # создать архив test.rar и добавить туда два файла (файлы копируются в архив)
unrar x test.rar # разархивировать
zip -r test.zip filename # архивировать (файлы копируются в архив)
unzip test.zip # разархивировать
bzip2 filename # архивировать в filename.bz2 (файлы перепещаются в архив)
bunzip2 filename.bz2 # разархивировать
gzip filename # архивировать в filename.gz (файлы перепещаются в архив)
tar --totals -cvf archive.tar file1 file2 file3 # архивировать три файла
wget https://github.com/librespeed/speedtest-cli/releases/download/v1.0.10/librespeed-cli_1.0.10_linux_amd64.tar.gz # загрузить архив
gunzip librespeed-cli_1.0.10_linux_amd64.tar.gz # извлечь из gz в tar
tar -tf librespeed-cli_1.0.10_linux_amd64.tar # отобразить содержимое архива
tar -xvf librespeed-cli_1.0.10_linux_amd64.tar # разархивировать
./librespeed-cli --help
./librespeed-cli --json

### gpg

gpg -c filename # зашифровать данные
gpg filename.gpg # расшифровать данные
gpg --gen-key # создавать пару ключей (публичный и приватный ключи)
gpg --export -a 'User Name' > publickey.asc # экспорт публичного ключа
gpg --import publickey.asc # импорт на второй стороне
gpg --encrypt --recipient 'Recipient Name' filename # зашифровать данные с использованием публичного ключа получателя, только владелец приватного ключа сможет расшифровать эти данные
gpg --decrypt encryptedfile.gpg # расшифровать данные можно с помощью приватного ключа
gpg --sign filename # подписывать данные с использованием приватного ключа для подтверждения их подлинности и целостности
gpg --verify signedfile.gpg # проверка подписи с использованием публичного ключа отправителя

## curl

curl ifconfig.me # узнать внешний ip
curl -v telnet://192.168.3.100:22 # првоерить доступность порта и отобразить кому он принадлежит
curl -s -o /dev/null http://google.com # подавить весь вывод (статистику --silent и --output)
curl -s -o /dev/null --show-error --fail http://google.com # оставить вывод ошибок
curl http://192.168.3.101:8081/api/ --connect-timeout 5 # задать timeout ожидания ответа в секундах
curl -IL https://github.com/Lifailon/hwstat/archive/refs/tags/hwstat-0.0.8.zip # получить информацию о файле перед скачиванием (--head/--location)
curl -O https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh # скачать файл
curl -o /tmp/hwstat.sh https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh # указать путь
curl -o /usr/bin/nettraffic https://raw.githubusercontent.com/marssantoso/nettraffic/master/nettraffic; sudo chmod 755 /usr/bin/nettraffic; ls /usr/bin/nettraffic
curl -I https://losst.pro # забрать заголовки страницы (server, last-modified)
curl -Ik https://192.168.3.104:9443/ # игнорировать ошибку самоподписанного сертификата SSL (--insecure)
curl -X POST -H 'ServiceName: PingTo-InfluxDB' -d '' http://192.168.3.99:8080/stop-service # -H (--header) и -d (Body/--data)
curl -X POST -H 'Content-Type: application/json' --data '{"param1":"test1","param2":"test2"}' http://test.com # получить данные в формате JSON
curl -u <user:password> https://test.com/endpoint # авторизация
curl --insecure --ssl-reqd "smtps://smtp.yandex.ru" --mail-from "src@yandex.ru" --mail-rcpt "dst@yandex.ru" --user "src@yandex.ru" --upload-file out.txt # отправка email через SMTPS (SMTP over SSL/TLS) сервер 
curl -x "http://Proxy:Proxy@192.168.3.100:9090" "https://kinozal.tv/rss.xml" # использовать Proxy-сервер
--data-raw '{"key":"value"}' # отправляет данные без кодирования (например, в JSON), в загаловке запроса указывается тип данных (-H "Content-Type: application/json")
--data-urlencode "key=value" # применяет URL-кодирование к данным
-L # следить за перенаправлениями (в случае, если URL перенаправляет на другое место)

### influxdb

ip="192.168.3.104"
db="dbash"
table="icmp_metrics_table"
server="google.com"
host=$(hostname)
date=$(echo $EPOCHREALTIME | sed -E "s/\..+//")"000000000"
ping=$(ping $server -c 1)
loss=$(printf "%s\n" "${ping[@]}" | grep -Eo "[0-9]+%" | sed "s/%//")
if (( $(echo "$loss != 100" | bc) )); then
    status="true"
    rtt=$(printf "%s\n" "${ping[@]}" | grep rtt | awk -F"/" '{print $5}')
else
    status="false"
    rtt="0"
fi
curl -i -XPOST "http://$ip:8086/write?db=$db" --data-binary "$table,host=$host,server=$server status=$status,rtt=$rtt $date"

## json

### jqlang

https://github.com/jqlang/jq
https://jqlang.github.io/jq/manual/
curl -s -H "Accept: application/json" 'https://check-host.net/check-ping?host=yandex.ru&max_nodes=3' | jq . # проверка ping/dns/http/tcp/udp
curl -H "Accept: application/json" https://check-host.net/check-result/12bec666k4e9 # получить результат проверки по id
curl -s -H "Accept: application/json" https://check-host.net/nodes/ips | jq .nodes # список node
curl -s -H "Accept: application/json" https://check-host.net/nodes/ips | jq '.nodes | length' # количество дочерних объектов
curl -s -H "Accept: application/json" https://check-host.net/nodes/ips | jq .nodes[1] # получить значение первого обхекта
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'keys_unsorted[]' # получить список всех вложенных ключей
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'to_entries[].key' # получить список всех вложенных ключей
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq '.nodes."us1.node.check-host.net"' # получить значение дочернего ключа nodes по имени
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'to_entries[] | {hostname: .key, location: .value.location[2]}' # получить формат key-value и обратиться к индексу вложенного списка
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'to_entries[-1] | .key' # забрать только имя последнего хоста
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'to_entries[-1] | .value.ip' # забрать только ip последнего хоста
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq .nodes | jq 'to_entries[].value.location[0] == "ru"' # проверить на true/false
curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | jq '.nodes | to_entries[] | select(.value.location[0] == "ru") | .key' # получить только найденные объекты

selected=$(echo $messages | jq ".result[] | select(.message.chat.id == $TG_CHAT and .message.entities[0].type == \"$type\")") # отфильтровать по двум условиям (при фильтрации по номеру кавычки не применяются)
echo $selected | jq ".[] | select(.name | index(\"$file_name_replace\"))" # приблезительный поиск (поиск по совпадению части слова)
echo $selected | jq "{date: .message.date, text: .message.text}" # забрать 2 значения у каждого элемента
echo $selected | jq ".message.date, .message.text"
echo $selected | jq -s .[-1] # забрать последний элемент, который не является массивом [] (-s)
echo $qbittorrent | jq ".[] | jq ".[] | {name: .name, size: (size: (.size / 1024 / 1024 / 1024 | tonumber * 100 | floor / 100 | tostring + \" GB\")}" # разделить байты, кб и мб для получения гб. Перевести в целое число (tonumber), умножить на 100 и разделить на 100, что бы округить до 2 знаков после запятой (floor). Добавить в конец текст (tostring).
echo $qbittorrent | jq ".[] | jq ".[] | {name: .name, progress: (.progress * 100 | floor / 100 * 100 | tostring + \" %\")}" # получить процент из дробной части (0,333 = 33%)
echo $qbittorrent | jq ".[] | jq ".[] | {name: .name, date: (.added_on + 3 * 3600 | strftime(\"%H:%M:%S %d.%m.%Y\"))}" # получить дату (strftime)

lsblk -e7 -f --json | jq -r '.blockdevices[] | "\(.name) - \(.size)"'

service_name="cron"
service_list=$(systemctl list-units --all --type=service --plain --no-legend --no-pager --output=json | jq --arg service_name "$service_name" '
    .[] | select(.unit | test($service_name))
')
uptime=$(systemctl status $service_name | grep -P "Active:.+;" | sed -r "s/.+; | ago//g")
startup=$(systemctl status $service_name | grep -oP "enabled|disabled" | head -n 1)
echo $service_list | jq --arg uptime "$uptime" --arg startup "$startup" '
    . + {uptime: $uptime, startup: $startup}
'

## brew

https://github.com/Homebrew/brew
https://github.com/Homebrew/install
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" # установить менеджер пакетов macOS/Linux
echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"' >> ~/.profile
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
brew --version
brew update

### fx

https://github.com/antonmedv/fx
brew install fx
curl -s -H "Accept: application/json" https://check-host.net/nodes/ips | fx .
curl -s -H "Accept: application/json" https://check-host.net/nodes/ips | fx .nodes[1]

### dasel

https://github.com/TomWright/dasel
brew install dasel # аналог jq / yq , с поддержкой JSON, YAML, TOML, XML и CSV (поддерживает преобразование между форматами и может использоваться как пакет Go)
echo '{"name": "Tom"}' | dasel -r json 'name'
echo '{"name": "Tom"}' | dasel -r json -w yaml # конвертировать json в yaml
echo '{"name": "Tom"}' | dasel put -r json -t string -v 'contact@tomwright.me' 'email' # добавить свойство
echo '{"email": "contact@tomwright.me","name": "Tom"}' | dasel delete -r json '.email' # удалить свойство

### xq

https://github.com/sibprogrammer/xq
brew install xq # для XML и HTML
apt-get install xq
curl -sSL https://bit.ly/install-xq | sudo bash
curl -s https://kinozal.tv | xq -q "head"
curl -s https://kinozal.tv | xq -n -q "head"
curl -s https://kinozal.tv/browse.php?s=the+rookie | xq -q "body"
curl -s https://kinozal.tv/rss.xml | xq -x //rss//channel//item//link

## yq

https://github.com/kislyuk/yq
pip install yq # для YAML/XML/TOML
cat /etc/netplan/*.yaml | yq .network.ethernets.ens33.addresses # -y (raw-формат)

### netcheck

sudo curl -s https://raw.githubusercontent.com/Lifailon/Check-Host/rsa/netcheck/netcheck.sh -o /usr/bin/netcheck
sudo chmod +x /usr/bin/netcheck
netcheck -t ping yandex.ru
netcheck -n
netcheck -t ping yandex.ru ru1.node.check-host.net
netcheck -t dns yandex.ru
netcheck -t http yandex.ru:443 5
netcheck -t tcp yandex.ru:443

## xml

### xmllint

apt-get install libxml2-utils
snap install libxml2
brew install libxml2
scoop install libxml2
curl -s https://kinozal.tv/rss.xml | xmllint --xpath '/rss/channel/item[1]/link/text()' -

links=$(curl -s https://kinozal.tv/rss.xml | xmllint --xpath 'count(//item)' -)
for ((i=1; i<=$links; i++)); do
    link=$(echo "$xml_data" | xmllint --xpath "//item[$i]/link/text()" -)
    echo "Link $i: $link"
done

irm https://kinozal.tv/rss.xml # 100 последних (новых) публикаций с главной страницы (RSS-лента)
irm https://habr.com/ru/rss/users/Lifailon/articles # публикации на Habr

### xq

https://github.com/sibprogrammer/xq
curl -sSL https://bit.ly/install-xq | sudo bash
brew install xq
apt install xq
curl -s https://kinozal.tv/rss.xml | xq # formatted xml
curl -s https://kinozal.tv | xq # formatted html

## grep

cat /var/log/auth.log | grep sshd # логи всех SSH-подключений
cat /etc/passwd | grep -w sys # поиск целого слова, окруженное пробелами (-w)
cat /etc/ssh/sshd_config | grep -win port # не учитывать регистр (-i) и отобразить номера строк (-n)
ss -n | grep -P ":22|:80|:443|:8080" # искать по нескольким шаблонам, использовать Regex (-E)
ss -n | grep -Pc ":22|:80" # вывести кол-во (--count) совпадений
ss -n | grep "192.168.3...:" # поиск любых двух символов (.)
ss -n | grep "192.168.3.*:" # поиск любого кол-ва (*)
cat /etc/ssh/sshd_config | grep -v "#" # вывести значения, не подходящие под критерии поиска (-v)
cat /etc/zabbix/zabbix_agentd.conf | grep -v "^#" # отсеить только в начале строки (^)
cat /etc/zabbix/zabbix_agentd.conf | grep "=$" # найти строки, которые кончаются ($) на символ "=" (получить все параметры)
cat /etc/zabbix/zabbix_agentd.conf | grep -Pv "^$|^#" # удалить пустые строки (^$) и комментарии (^#)
cat /etc/zabbix/zabbix_agentd.conf | grep -E "#+{5}" # регулярное выражение (-E), где последний символ "#" повторяется 5 или более раз
echo -e "Test\ntest\n123-45" | grep -E "[a-zA-Z\-]" # искать только текст (где есть буквы и тире)
echo 'test<version>1.2.3</version>test' | grep -P -o "(?<=<version>).*(?=</version>)" # найти неизвестное значение (.*) между известными и вывести только найденное (-o)
echo "test<version>3.6.4</version>test" | grep -Eo '[0-9.]+' # найти любую цифру и точку на конце, которые повторяются любое кол-во раз подряд
echo $(lshw -class bus) | grep -P -o "(?<=Motherboard product: ).*(?=serial)" # с применение группировки (-P)
zabbix_path=$(systemctl status zabbix-agent | grep -Po "(?<=-c ).*(?=.conf)" | sed "s/$/.conf/") # забрать путь до конфигурационного файла Zabbix агента
cat $zabbix_path | grep -E "^Server=|^ServerActive=" # найти имя сервера
cat $zabbix_path | grep -Po "(?<=^Server=).+" # вывести только имя сервера
resolvectl | grep "DNS Servers" -m 1 # напечатать только первое совпадение (-m int)
networkctl status | grep -A 3 "DNS:" # найти строку и напечатать три строки после нее (-A)
networkctl status | grep -B 3 "DNS:" # найти строку и напечатать три строки до нее (-B)
networkctl status | grep -C 1 "DNS:" # найти строку и напечатать одну строки до нее и одну после (-C)
resolvectl | grep -Ex ".+DNS Servers:.+" # вывести строки с точным совпадение (-x/like), сопоставлять только целые строки
if echo "GET" | grep -Eq "^GET"; then echo da; else echo net; fi # подавлять вывод (-q) для проверки условия
curl https://api.github.com/repos/PowerShell/PowerShell/releases/latest | grep -Eom 1 "https://.+.deb" # забрать только первый подходящий под поиск

## sed

cat /etc/passwd | sed -n "1,5p" # отобразить с первой по пятую строку (p)
cat /etc/passwd | sed "$ d" # удалить (d) последнюю строку
cat /etc/passwd | sed "1,3d" # удалить c первой по третью строку (2,3d)
echo "One 1" | sed "s/One/Two/; s/1/2/" # заменить One на Two и 1 на 2
cat /etc/zabbix/zabbix_agentd.conf | sed "s/127.0.0.1/192.168.3.102/" # > /etc/zabbix/zabbix_agentd.conf # заменить (s) ip-адрес
cat /etc/zabbix/zabbix_agentd.conf | sed "/^#\|^$/d" # удалить пустые строки (^$) и комментарии (^#)
timedatectl | grep zone | sed -E "s/.+zone: //" # удалить любое кол-во лимволов до слова "zone: " включительно, используя Regex (-E/-r)
echo -e "test\ntest" | sed "2s/test/test2/" # заменить во второй строке (2s)
echo -e "test\ntest\ntest\ntest" | sed "2,3s/test/test2/" # заменить во второй и третей строке (2,3s)
echo -e "test\ntest\ntest\ntest" | sed "2ctest2" # заменить вторую строку (2c)
echo "The test and test" | sed "s/test/test2/g" # заменить для каждого совпадения (/global)
echo "The test and test" | sed "s/test/test2/2" # заменить для второго совпадения (/2)
echo "line2" | sed "i\line1" # добавить строку в начало (i)
echo "line1" | sed "a\line2" # добавить строку в конец (a) или в после указанной строки (2a)
echo "11 22 33 34" | sed "y/123/234/" # заменить 1 на 2, 2 на 3, 3 на 4 (y)
ls -R | grep ':' | sed "s/:$//; s/[^\/]*\// - /g" # удалить ":" в конце и заменить вначале строки "/любое кол-во символов между/" на " - " для всех (/g global)
echo "test<version>3.6.4</version>test" | sed -r 's/[^<]*<(.*)>.*/\1/;s/<.*//;s/.*>//' # использовать regex (-r)
ps aux | grep -E "^zabbix .+ -c" | sed -E "s/^zabbix.+-c //" # найти процесс zabbix с ключем -c и оставить путь conf
echo "MPEG-H HEVC, 88.5 Мбит/с, 3840x2160, 23.976 кадр/с, 10 бит" | sed -nr 's/.* ([0-9]+x[0-9]+).*/\1/p' # выводить только найденные строки (-n) с заменой (s/), ищем только цифры [0-9] где одно или более вхождений (+) и между ними "x", вывести только первую группу поиска (то, что в скобках) на печать (/p)

## awk

cat /etc/passwd | awk -F: '{print "name: " $1 " \t Dir: " $NF}' # вывести содержимое первого и последнего ($NF) элемента в строке, используя разделитель ":" и табуляцию (\t)
echo 'one two three four' | awk '{print $(NF-1)}' # вывести содержимое преподследнего элемента
echo 'one two three four five' | awk '{print $((NF/2)+1)}' # вывести содержимое из середины
echo "One Two Three" | awk '{$3="Four"; print $0}' # заменить третье значение/переменную в строке
cat /etc/passwd | awk 'BEGIN{FS=":"; OFS=" - "} {print $1,$7}' # указать разделитель послей (элементов) на вход (FS) и заменить его на выходе (OFS)
uptime | awk 'BEGIN{RS=" "; ORS="\n"} {print $0}' # указать разделитель записей (строк) на входе (RS) и заменить его на выходе (ORS)
echo -e "12345\n54321" | awk 'BEGIN{FIELDWIDTHS="2 3"}{print $1,$2}' # указать фиксированное кол-во символов для разделения
lsof | awk '{if($7=="REG")print $0}' # условие для выборки по столбцу
cat /etc/ssh/sshd_config | awk '/Port / {print $2}' # условие поиска для вывода
cat /etc/ssh/sshd_config | awk 'length $0 > 1' # вывести строки, которые длиннее, чем 1 символ (удалить пустые строки)
cat /var/log/syslog | grep "$date" | awk '{print length($6)}' # вывести длинну значения
awk 'BEGIN{x = "low"; print toupper(x)}' # использовать функцию для перевода в вверхний регистр
awk 'BEGIN{x = "LOW"; print tolower(x)}' # использовать функцию для перевода в нижний регистр
echo "1 2 3 4:5:6" | awk '{item=$4; split(item,array,":"); print array[2]}' # разбить 4 значение на массив (используя функцию split) и забрать значение по 2-му индексу
free | awk '{if (NR == 2) print $0}' # вывести только вторую строку
free | awk '{if (NR >= 2) print $0}' # вывести втроую и последующие строки
free | awk '{if (NF >= 5) print $0}' # вывести строки, где 5 или больше значений
cat /etc/passwd | awk '{ if (NR >= 10 && NR <= 20) print $0}' # вывести с 10 по 20 строки
last | sed -n 1p | awk '$2=" ",$4=" "{print $0}' # вывести все, кроме 2 и 4 значения (заменить)
ps -A | awk '{sum=""; for(i=1;i<=NF;i++) { if (i != 2) {sum=sum" "$i} } print sum}' # вывести все, кроме 2-го значения

## printf

top=$(top -bn1)
printf "%s\n" "${top[@]}" # вывести вывод массива построчно
printf "%.2f \n" 1.1111 # округлить до 2 символов после запятой
printf "%.0f \n" 1.6 # удалить дробную часть (округлить до 2)
printf "Arg1: %s\nArg2: %s\n" "10" "20" # принимает и выводит аргументы (%s) в виде строки

## cut

echo "1 2 3" | cut -c 1,5 # вывести первый и пятый симов (--bytes/--characters)
echo "1 2 3" | cut -c 1-3 # вывести с первой по третий символ
echo "1 2 3" | cut -c3- # удалить первые 2 символа
echo -e "test1,test2,test3\ntest1,test2,test3" | cut -d , -f 2-100 # указать разделитель полей/столбцов (--delimiter) и какие столбцы вывести (--fields) с 2 по 100
echo -e "test1,test2,test3\ntest1,test2,test3" | cut -d , -f 1,3 | sed "s/,/ /" # вывести 1 и 3
echo -e "test1,test2,test3\ntest1 test2 test3" | cut -d , -f 1,3 -s # печатать строки, где есть разделитель (-s)

### rev

echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | rev | cut -d \\ -f 1 | rev # забрать последний элемент в пути (вначале разворачивает всю строку, забирает первый элемент и разворачивает строку обратно)
echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | sed -r 's/.+\\//' # удалить все до последнего слеша
echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | sed 's/.*\\\(.*\)/\1/' # удаляет все до последнего слеша и забирает одну группу захвата, что остается после удаления, и заменяет вывод на первую группу (1)
echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | awk -F '\\' '{print $NF}' # забрать последний элемент массива (NF)

## tr

echo "10 20 100 200" | tr 1 2 # translate заменяет 1 на 2 для всех подходящих сомволов (20 20 200 200)
echo "1 2 3" | tr " " "," # заменить пробелы на запятые (1,2,3)
echo "1 2 3" | tr -d " " # удалить пробелы (123)

## man

### cheat.sh

curl cheat.sh/curl
curl cheat.sh/grep
curl cheat.sh/sed
curl cheat.sh/awk
curl cheat.sh/jq
curl cheat.sh/iptables
curl cheat.sh/find

### tldr

pip3 install tldr # упрощенный вариант man с примерами использования
tldr curl # веб-версия: https://manned.org/man/curl

## tools

### debug

trap 'echo "$BASH_COMMAND"' DEBUG # построчная отладка скриптов bash, команда trap перехватывает сигнал DEBUG, посылаемый перед выполнением команды и выводит команду на экран
trap 'echo "$BASH_COMMAND";read' DEBUG # read ожидает ввода с клавиатуры (Enter или Ctrl+C) перед выполнением каждой командой
bash -x script.sh # отладка (печать команд и их аргументов по мере их выполнения)
bash -x -c "ls -l" | grep *.sh | awk '{print $5,$NF}' # запуск команды через интерпритатор bash и вывод отладки
bash --debug script.sh # проверка на ошибки
apt-get install shellcheck # установить shellcheck
shellcheck -S error hwstat.sh # error/warning/info/style
pip3 install thefuck # установить thefuck
bas hwstat.sh # запустить команду с ошибкой
fuck # автоматически исправляет последнюю ошибочную команду из выпадающего списка (up/down)

### fzf

apt install fzf # установить fzf
history | fzf # интерактивный поиск с фильтрацией
eval $(history | fzf | awk '{print $2}') # выполнить (eval) выбранную команду из списка (добавить в макрос)
ls *.json | fzf | xargs cat | jq . # вывести содержимое выбранного json файла через fzf
find / -name "*.yaml" | fzf | xargs cat # найти в системе все файлы yaml и запустить по ним поиск

### exa

echo 'deb http://cz.archive.ubuntu.com/ubuntu jammy main universe' >> /etc/apt/sources.list && apt update
apt install exa
exa $(pwd) -l --icons # аналог ls

### bat

apt install bat
bat /etc/netplan/*.yaml # аналог cat с подсветкой синтаксиса

### column

column /etc/passwd -t -s ":"
netcheck -t ping yandex.ru us1.node.check-host.net | sed -r 's/"//g; s/,$//; s/\{|\}|\[|\]//' | column -t -s ":" # распарсить JSON и добавить отступ (табуляцию) для колонок

### wc

ls /home | wc -l # word count выводит количество строк (--line)
ls /home | wc -w # количество слов (--words)
ls /home | wc -m # количество символом (--chars)
ls /home | wc -c # количество символов/байт (--bytes)

### bc

echo "(5.5-2.2)" | bc # математические вычисления
echo "(5.5-2.2)" | bc | sed -E "s/\..+//" # удалить дробную часть
echo "1 < 2" | bc # возвращает булевое значение (1 - да или 0 - нет)
echo "1 > 2" | bc # 0
icmp_ignore=$(cat /proc/sys/net/ipv4/icmp_echo_ignore_all) # забрать значение
if (( $(echo "$icmp_ignore == 1" | bc) )); then echo "true"; else echo "false"; fi # проверить в условии арефметическое значение на равенство (возвращает 0 - false или 1 - true)

a=1
b=0.55
echo $(bc <<< "scale=2; $a+$b")
echo "print $a+$b" | perl
echo "print($a+$b)" | python3
echo "print($a+$b)" | lua
echo "puts $a+$b" | ruby
pwsh -Command $a+$b

### paste

echo -e "key1\nkey2\nkey3" > 1.txt
echo -e "value1\nvalue2\nvalue3" > 2.txt
paste 1.txt 2.txt -d : # объединяет два файла в один многоколоночный вывод
cat /etc/passwd | paste -s -d + # объеденить (join) многострочный файл, используя указанный delimiter

### diff

echo -e "test1\ntest2" > 1.txt
echo -e "test\ntest2\ntest3" > 2.txt
diff 1.txt 2.txt -c # ! есть изменения, + есть новая строка
diff 1.txt 2.txt -yi # сравнивает в две колонки (| есть изменения, + есть новая строка) и игнорировать регистр (-i)
diff 1.txt 2.txt -u # объеденяет два файла в один вывод с отображением изменений (+/)
diff 1.txt 2.txt -ibBEt # не учитывать пробелы (-b) и пустые строки (-B), игнорировать изменения в табуляциях (-E) и заменить табуляции на пробелы в выводе (-t)
diff -c <(echo "$predu") <(echo "$du") # сравнить содержимое переменных

### diff-so-fancy

snap install diff-so-fancy
diff -u file-1.txt file-2.txt | diff-so-fancy

### jdupes

apt install jdupes
jdupes . # поиск дубликатов

### sort

cat /etc/passwd | sort -r # отсортировать вывод по алфовиту в обратном порядке (-r)
du -h ~ | sort -n # сортировать по арифметическому значению (-n) размер файлов и директорий
ls -l | sed 1d | sort -nk5 # сортировка по пятой колонке (-k)
cat $tmp | sort -t "." -nk4 # сортировать по четвертой колонке, используя разделитель (-t) точку

### uniq

echo -e "1 2\n1 2\n2 1\n1 2" | uniq # удаляет соседние одинаковые строки
echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq # удалить все дубликаты
echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq -c # добавляет в начало каждой строки кол-во повторений
echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq -u # отобразить только уникальные строки, без строк с повторениями

### fold

ls -l | fold -w 50 # задать ширину вывода каждой строки, выпадающее за указанный предел переносится на новую строку
ls -l | fold -w 50 -s # разбивать строки только на символах пробела (--space)

### head

cat /var/log/syslog | head -n 5 # выводит первые 5 строк файла

### tail

cat /var/log/syslog | tail -n 5  # просмотр последних 5 строк файла
tail -f /var/log/syslog # просмотр содержимого файла в реальном времени

### less

less /var/log/dmesg # вывести лог ядра с возможностью пролистывания

### watch

watch df -h # выводит на экран и обновляет состояния подключенных устройств каждые 2 секунды

### EOF

echo "line1" | tee test.txt # перезаписать файл (>)
ls > /dev/null # перенаправить вывод в null
echo "line2" | tee -a test.txt # добавить (>>) текст новой стройокй в конец файла
echo -e "line3\nline4" >> test.txt # добавить две новые строки
tee test.txt <<EOF
line1
line2
EOF

### xargs

du -a /var/log | awk '{print $2}' | xargs fincore # передать вывод первой команды построчно в аргументы следующей

### split

split -l 100 input_file.txt output_prefix # разделить файл на части по 100 строк в каждой
split -b 10M input_file.txt output_prefix # разделить файл на части по указанному размеру (например, 10MB)

## find

find / -name "*.sql" # найти файлы, начать поиск с корня (/)
find / -iname "mysql" # найти файлы не учитывая регистр (-i)
find ~ -name "test.*" -not -name "*.conf" # найти все файлы с наименование test, которые имеют любое расширение, за исключением (-not) расширения .conf
find ~ -amin -10 # поиск файлов по дате последнего чтения (-amin) которые просматривались (cat/nano) за последние 10 минут
find ~ -type f -mmin -10 # найти файлы (-type f), которые были модифицированны за последние 10 минут (-nmin)
find ~ -type f -mtime +1 -mtime -7 # найти все файлы, модифицированные между 1 и 7 днями назад
find ~ -type d -mtime +1 -mtime -7 # поиск директорий
find ~ -size +50M -size -100M # поиск файлов в Linux по их размеру, от 50 до 100 мегабайт
find / -perm 444 # поиск файлов по режиму доступа (только чтение для всех)
find /home/lifailon/ -user root # поиск файлов по владельцу
find /home/lifailon/ -group root # поиск по группе
find /root/ -empty # поиск пустых файлов или директорий

### exec

touch -t 202306222200.15 /tmp/test.txt # создать файл с указанной датой создания
find /tmp -type f -mtime +30 -exec rm -f {} \; # удалить все файлы, котоыре не изменялись больше 30 дней
find /tmp -type f -name "*.txt" -exec rm -f {} \; # удалить все текстовые файлы в директории tmp
dd if=/dev/zero of=/var/log/test.log count=11 bs=1M # создать файл заполненный нулями указанного размера
find /var/log -type f -name "*.log" -size +10M -exec rm -f {} \; # удалить все лог-файлы, объёмом больше 10 Мбайт

### locate

cargo install locate
updatedb # обновить индексы базы данных
locate filename.txt # найти по имени файла
locate -i filename.txt # игнорировать регистр
locate '*.jpg' # найти все файлы по расширению
locate -n 10 filename.txt # вывести 10 результатов
locate -d /path/to/directory filename.txt
locate -r 'pattern.*\.txt$' # использовать регулярные выражения

## cron

ls /etc/cron.d/ # директория хранения задач различных пакетов (atop, sysstat)
ls -l /etc/cron.hourly && ls -l /etc/cron.daily && ls -l /etc/cron.weekly && ls -l /etc/cron.monthly # директории для скриптов, которые надо выполнять раз в час, день, неделю и месяц
crontab -l # просмотр задач
crontab -l | grep -Pv "^$|^#" # отобразить только активные задания
crontab -u lifailon -l # отобразить задачи пользователя root
crontab -e # создать задачу от текущего пользователя
sudo crontab -u root -e # создать задачу от пользователя root
crontab -r # очистить все задачи

cat /etc/crontab

#### # .---------------- минута (0 - 59)
#### # |  .------------- час (0 - 23)
#### # |  |  .---------- мень месяца (1 - 31)
#### # |  |  |  .------- месяц (1 - 12) OR jan,feb,mar,apr...
#### # |  |  |  |  .---- день недели (0 - 6) (Воскресень 0 или 7) или sun,mon,tue,wed,thu,fri,sat
#### # |  |  |  |  |
#### # *  *  *  *  * user-name command to be executed
####  17  *  *  *  *   root    cd / && run-parts --report /etc/cron.hourly
####  25  6  *  *  *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
####  47  6  *  *  7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
####  52  6  1  *  *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )

0,14,29,44 * * * * # каждые 15 минут
*/15 * * * * # каждые 15 минут

00 23 * * * systemctl restart zabbix-agent && echo $(date): Reboot Zabbix Agent use cron >> /var/log/reboot.log # выполнять перезапуск службы каждый день в 23:00 и писать в лог
00 03 * * 6 echo $(date): Reboot Operating System use cron >> /var/log/reboot.log && /sbin/reboot # выполнять перезагрузку системы один раз в субботу в 3 часа ночи
@reboot date >> ~/date-reboot.log # выполнять один раз после перезагрузки

journalctl -eu cron
cat /var/log/syslog | grep -i cron

#!/bin/bash
addr="google.com"
path="/var/log/icmp-test.log"
date=$(date | awk '{print $3,$2,$4}')
loss=$(ping -c 2 $addr | grep -Ewo "[0-9]+%")
if [ $loss = "100%" ]; then
    echo "$date: $addr - unavailable" >> $path
else
    echo "$date: $addr - available" >> $path
fi

echo "*/1 * * * * bash /root/google-icmp-test.sh" >> /var/spool/cron/crontabs/root # добавить задачу в планироващик на выполнение скрипта каждую минуту

cp /etc/hosts /etc/hosts.bak # backup файла
echo "11.11.11.11 google.com" >> /etc/hosts # изменить адрес для недоступности хоста
cp /etc/hosts.bak /etc/hosts # восстановить файл
cat /var/log/icmp-test.log | grep unavailable # отфильтровать лог по unavailable

## systemctl

systemctl reload ssh # обновить конфигурацию сервиса из файла юнита (если у юнита есть эта функция)
systemctl status ssh # отображает состояние системы, юнитов (в том числе Failed) и запущенные процессы пользователей
systemctl status sshd | grep -P "Active.+;" | sed -r "s/.+; | ago//g" # время работы службы
systemctl start ssh # запустить юнит (до перезагрузки)
systemctl stop ssh # остановить юнит (до перезагрузки)
systemctl restart ssh # перезапустить сервис
systemctl enable ssh # добавить в автозагрузку
systemctl disable ssh # удалить из автозагрузки
systemctl mask ssh # выключить юнит, который нельзя будет запустить вручную или как зависимость (создает симлинк на /dev/null)
systemctl unmask ssh # включить юнит (удалить симлинк)
systemctl daemon-reload # перезапустить юнит systemd
systemctl cat ssh # отобразить путь и содержимое unit-файла
systemctl edit --full ssh # открыть для редактирования файл юнита
systemctl list-dependencies ssh # дерево зависимостей
systemctl list-dependencies ssh --reverse # зависящие сервисы от указанного юнита
systemctl list-units --type service --all # отображение статуса всех сервисов
systemctl list-unit-files | sed "1d;$ d" | sed "$ d" | wc # отобразить кол-во всех файлов конфигурации сервисов на диске;
systemctl list-unit-files | grep zabbix # отфильтровать по имени
systemctl list-unit-files --type=service # список всех сервисов
systemctl list-unit-files --type=service --state=enabled # список сервисов, добавленных в автозагрузку
systemctl list-units --all --type=service --plain --no-legend --no-pager --output=json
--all: выводить все типы юнитов, включая активные, неактивные и остановленные
--type=service: выводить только системные службы управляемые systemd (не ключает в вывод другие типы юнитов, такие как socket или device)
--plain: вывод в текстовом формате без форматирования
--no-legend: отключает вывод заголовков для столбцов
--no-pager: отключает использование постраничного вывода (less)
ls /usr/lib/systemd/system # юниты поставляемые вместе с системой и устанавливаемыми приложениями
ls /run/systemd/system # юниты созданные динамически в runtime
ls /etc/systemd/system # юниты системного администратора

### unit

#!/bin/bash
while true; do
    addr="google.com"
    path="/var/log/icmp-test.log"
    date=$(date | awk '{print $3,$2,$4}')
    loss=$(ping -c 2 $addr | grep -Ewo "[0-9]+%")
    if [ $loss = "100%" ]; then
        echo "$date: $addr - unavailable" >> $path
    else
        echo "$date: $addr - available" >> $path
        tail -n 1 $path
    fi
    sleep 5
done

nano /etc/systemd/system/icmp-test-log.service

[Unit]
Description=icmp test output to log
After=network.target

[Service]
ExecStart=/bin/bash "/root/google-icmp-test.sh"
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
Type=simple

[Install]
WantedBy=multi-user.target

systemctl daemon-reload
systemctl enable icmp-test-log.service
systemctl start icmp-test-log
systemctl status icmp-test-log
tail -f /var/log/icmp-test.log
